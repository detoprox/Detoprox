#pragma once
#include <string>
#include <sstream>
#include <regex>
#include <map>
#include <vector>

/*
  Detoprox — TypeScript Client Generator (header-only, C++17)

  Lee un YAML OpenAPI 3.0 “simple” (como el que emite nuestro exporter.hpp)
  y genera un cliente TypeScript con:

    - createClient({ baseUrl?, token? })
    - funciones por endpoint: <method>_<path_sanitizada>(params?)
      donde params?: { path?: Record<string,string|number>, body?: any, query?: Record<string,string|number> }

  Límites:
    - Parser de YAML muy básico por regex (asume formato del exporter).
    - No resuelve $ref complejos; solo interfaces desde components.schemas.
*/

namespace dpx {

struct OATypeDef { std::map<std::string,std::string> fields; };

inline std::map<std::string,OATypeDef> dpx_parse_schemas_from_openapi(const std::string& y){
    std::map<std::string,OATypeDef> models;
    std::regex schemasStart(R"(^\s*components:\s*$)");
    std::regex schemasSec(R"(^\s*schemas:\s*$)");
    std::regex modelRe(R"(^\s{2,}([A-Za-z_][A-Za-z0-9_]*)\:\s*$)");
    std::regex propsRe(R"(^\s{4,}properties:\s*$)");
    std::regex propRe(R"(^\s{6,}([A-Za-z_][A-Za-z0-9_]*)\:\s*$)");
    std::regex typeRe(R"(^\s{8,}type:\s*([a-zA-Z0-9_-]+)\s*$)");

    std::stringstream ss(y); std::string line;
    bool inComponents=false, inSchemas=false, inModel=false, inProps=false;
    std::string curModel, curProp; OATypeDef cur;
    while (std::getline(ss, line)) {
        std::smatch m;
        if (!inComponents && std::regex_match(line, m, schemasStart)) { inComponents=true; continue; }
        if (inComponents && !inSchemas && std::regex_match(line, m, schemasSec)) { inSchemas=true; continue; }
        if (inSchemas && std::regex_match(line, m, modelRe)) {
            if (inModel && !curModel.empty()) { models[curModel]=cur; cur=OATypeDef{}; }
            inModel=true; inProps=false; curModel=m[1]; continue;
        }
        if (!inModel) continue;
        if (std::regex_match(line, m, propsRe)) { inProps=true; continue; }
        if (inProps && std::regex_match(line, m, propRe)) { curProp=m[1]; continue; }
        if (inProps && std::regex_match(line, m, typeRe)) {
            if (!curProp.empty()) cur.fields[curProp]=m[1];
            curProp.clear(); continue;
        }
        // dedent => fin de modelo
        if (inModel && line.rfind("  ",0)!=0) {
            models[curModel]=cur; cur=OATypeDef{}; inModel=false; inProps=false; curModel.clear();
        }
    }
    if (inModel && !curModel.empty()) models[curModel]=cur;
    return models;
}

inline std::string dpx_ts_type(const std::string& oatype){
    if (oatype=="integer") return "number";
    if (oatype=="number")  return "number";
    if (oatype=="boolean") return "boolean";
    return "string";
}

inline std::string dpx_generate_typescript_client(const std::string& openapiYaml){
    // 1) Endpoints: 'paths' con path y método
    std::regex pathRe(R"(^\s{2}'([^']+)'\:\s*$)");
    std::regex methodRe(R"(^\s{4}(get|post|put|delete)\:\s*$)");
    std::stringstream in(openapiYaml);
    std::string line, curPath;
    std::vector<std::pair<std::string,std::string>> endpoints; // {method, path}

    while (std::getline(in, line)){
        std::smatch m;
        if (std::regex_match(line,m,pathRe)) { curPath=m[1]; continue; }
        if (std::regex_match(line,m,methodRe) && !curPath.empty()) { endpoints.emplace_back(m[1], curPath); }
    }

    // 2) Schemas: interfaces TS
    auto models = dpx_parse_schemas_from_openapi(openapiYaml);

    // 3) Emitir TS
    std::ostringstream ts;
    ts << "// Generated by Detoprox — TypeScript client (v0)\n";
    ts << "export interface ClientOptions { baseUrl?: string; token?: string }\n\n";

    for (auto& kv : models) {
        ts << "export interface " << kv.first << " {\n";
        for (auto& f : kv.second.fields) {
            ts << "  " << f.first << ": " << dpx_ts_type(f.second) << ";\n";
        }
        ts << "}\n\n";
    }

    ts <<
R"TS(export function createClient(opts: ClientOptions = {}) {
  async function request<T=any>(method: string, path: string, body?: any): Promise<T> {
    const url = (opts.baseUrl || '') + path;
    const res = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...(opts.token ? { Authorization: 'Bearer ' + opts.token } : {})
      },
      body: body !== undefined ? JSON.stringify(body) : undefined
    });
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error(`HTTP ${res.status} ${text}`);
    }
    const ct = res.headers.get('content-type') || '';
    return ct.includes('application/json') ? (await res.json()) as T : (await res.text() as unknown as T);
  }
)TS";

    for (auto& ep : endpoints) {
        std::string m = ep.first;
        std::string p = ep.second;
        std::string fn = m + std::string("_") + std::regex_replace(p, std::regex("[^a-zA-Z0-9]"), std::string("_"));
        ts << "  async function " << fn << "(params?: { path?: Record<string,string|number>; body?: any; query?: Record<string,string|number> }) {\n";
        ts << "    let path = '" << p << "';\n";
        ts << "    if (params?.path) { for (const k in params.path) { path = path.replace(':'+k, encodeURIComponent(String(params.path[k]))); } }\n";
        ts << "    if (params?.query) { const qs = Object.entries(params.query).map(([k,v])=> k+'='+encodeURIComponent(String(v))).join('&'); if (qs) path += (path.includes('?')?'&':'?') + qs; }\n";
        if (m=="get" || m=="delete") {
            ts << "    return request('" << m << "', path);\n";
        } else {
            ts << "    return request('" << m << "', path, params?.body);\n";
        }
        ts << "  }\n";
    }

    ts << "  return { request,";
    for (auto& ep : endpoints) {
        std::string fn = ep.first + std::string("_") + std::regex_replace(ep.second, std::regex("[^a-zA-Z0-9]"), std::string("_"));
        ts << " " << fn << ",";
    }
    ts << " };\n}\n";

    return ts.str();
}

} // namespace dpx
